--- a/src/utils/logger.cpp
+++ b/src/utils/logger.cpp
@@ -1,9 +1,12 @@
 #include "utils/logger.h"
 #include <filesystem>
 #include <iostream>
+#include <mutex>
+#include <atomic>
 
 namespace alphazero {
 namespace utils {
+
+static std::mutex g_logger_mutex;
 
 // Static member definitions
 bool Logger::initialized_ = false;
@@ -19,6 +22,9 @@ void Logger::init(const std::string& log_dir,
                   size_t max_files,
                   bool async_logging) {
+    // Thread-safe initialization
+    std::lock_guard<std::mutex> lock(g_logger_mutex);
+    
     if (initialized_) {
         return;
     }
@@ -29,6 +35,13 @@ void Logger::init(const std::string& log_dir,
             std::filesystem::create_directories(log_dir);
         }
         
+        // CRITICAL FIX: Initialize thread pool BEFORE creating async loggers
+        if (async_logging) {
+            // Larger queue size to prevent overflow
+            spdlog::init_thread_pool(32768, 4); // 32K queue, 4 threads
+            spdlog::flush_every(std::chrono::seconds(3));
+        }
+        
         // Create loggers
         mcts_logger_ = create_logger("mcts", log_dir, console_level, file_level, 
                                     max_file_size, max_files, async_logging);
@@ -41,11 +54,6 @@ void Logger::init(const std::string& log_dir,
         // Set global log level
         spdlog::set_level(console_level);
         
-        // Configure async logging thread pool if enabled
-        if (async_logging) {
-            spdlog::init_thread_pool(8192, 2); // queue size, worker threads
-        }
-        
         initialized_ = true;
         system_logger_->info("Logging system initialized. Log directory: {}", log_dir);
         
@@ -86,7 +94,7 @@ std::shared_ptr<spdlog::logger> Logger::create_logger(
         logger = std::make_shared<spdlog::async_logger>(
             name, sinks.begin(), sinks.end(), 
             spdlog::thread_pool(),
-            spdlog::async_overflow_policy::block);
+            spdlog::async_overflow_policy::overrun_oldest); // Don't block, drop old messages
     } else {
         logger = std::make_shared<spdlog::logger>(
             name, sinks.begin(), sinks.end());
@@ -103,28 +111,44 @@ std::shared_ptr<spdlog::logger> Logger::create_logger(
 
 std::shared_ptr<spdlog::logger> Logger::get_mcts_logger() {
     if (!initialized_) {
-        init();
+        std::lock_guard<std::mutex> lock(g_logger_mutex);
+        if (!initialized_) {
+            init();
+        }
     }
     return mcts_logger_;
 }
 
 std::shared_ptr<spdlog::logger> Logger::get_nn_logger() {
     if (!initialized_) {
-        init();
+        std::lock_guard<std::mutex> lock(g_logger_mutex);
+        if (!initialized_) {
+            init();
+        }
     }
     return nn_logger_;
 }
 
 std::shared_ptr<spdlog::logger> Logger::get_game_logger() {
     if (!initialized_) {
-        init();
+        std::lock_guard<std::mutex> lock(g_logger_mutex);
+        if (!initialized_) {
+            init();
+        }
     }
     return game_logger_;
 }
 
 std::shared_ptr<spdlog::logger> Logger::get_system_logger() {
     if (!initialized_) {
-        init();
+        std::lock_guard<std::mutex> lock(g_logger_mutex);
+        if (!initialized_) {
+            init();
+        }
     }
     return system_logger_;
 }
 
 void Logger::shutdown() {
+    std::lock_guard<std::mutex> lock(g_logger_mutex);
+    
     if (initialized_) {
+        // Flush all pending messages
         flush_all();
+        
+        // Give time for async loggers to process
+        std::this_thread::sleep_for(std::chrono::milliseconds(100));
+        
+        // Drop logger references
+        mcts_logger_.reset();
+        nn_logger_.reset();
+        game_logger_.reset();
+        system_logger_.reset();
+        
+        // Shutdown spdlog (destroys thread pool)
         spdlog::shutdown();
         initialized_ = false;
     }